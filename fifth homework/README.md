### A Индекс максимума на подотрезках
Реализуйте структуру данных "дерево отрезков" для эффективного вычисления номера максимального из нескольких подряд идущих элементов массива.

В первой строке вводится одно натуральное число N (1 ≤ N ≤ 100000) — количество чисел в массиве.
Во второй строке вводятся N чисел от 1 до 100000 — элементы массива.
В третьей строке вводится одно натуральное число K (1 ≤ K ≤ 30000) — количество запросов на вычисление максимума.
В следующих K строках вводится по два числа — номера левого и правого элементов отрезка массива (считается, что элементы массива нумеруются с единицы).

Для каждого запроса выведите индекс максимального элемента на указанном отрезке массива. Если максимальных элементов несколько, выведите любой их них.
Числа выводите в одну строку через пробел.

### B Суммы на подотрезках с изменением элемента (дерево отрезков)
Реализуйте эффективную структуру данных "дерево отрезков", позволяющую изменять элементы массива и вычислять суммы нескольких подряд идущих элементов. Решения, использующие структуру данных "дерево Фенвика", в данной задаче приниматься не будут.

В первой строке вводится одно натуральное число N (1 ≤ N ≤ 100000) — количество чисел в массиве.
Во второй строке вводятся N чисел от 0 до 100000 — элементы массива.
В третьей строке вводится одно натуральное число M (1 ≤ M ≤ 30000) — количество запросов.
Каждая из следующих M строк представляет собой описание запроса. Сначала вводится одна буква, кодирующая вид запроса (s — вычислить сумму, u — обновить значение элемента).
Следом за s вводятся два числа — номера левой и правой границы отрезка.
Следом за u вводятся два числа — номер элемента и его новое значение.

Для каждого запроса s выведите результат. Все числа выводите в одну строку через пробел.

### C Суммы на подотрезках с изменением элемента (дерево Фенвика)
Реализуйте эффективную структуру данных "дерево Фенвика", позволяющую изменять элементы массива и вычислять суммы нескольких подряд идущих элементов. Решения, использующие структуру данных "дерево отрезков", в данной задаче приниматься не будут.

В первой строке вводится одно натуральное число N (1 ≤ N ≤ 100000) — количество чисел в массиве.
Во второй строке вводятся N чисел от 0 до 100000 — элементы массива.
В третьей строке вводится одно натуральное число M (1 ≤ M ≤ 30000) — количество запросов.
Каждая из следующих M строк представляет собой описание запроса. Сначала вводится одна буква, кодирующая вид запроса (s — вычислить сумму, u — обновить значение элемента).
Следом за s вводятся два числа — номера левой и правой границы отрезка.
Следом за u вводятся два числа — номер элемента и его новое значение.

Для каждого запроса s выведите результат. Все числа выводите в одну строку через пробел.

### D Декартово дерево
Реализуйте структуру данных "декартово дерево", которая поддерживает множество S целых чисел, с котором разрешается производить следующие операции:
add(i) — добавить в множество S число i (если он там уже есть, то множество не меняется);
next(i) — вывести минимальный элемент множества, не меньший i. Если искомый элемент в структуре отсутствует, необходимо вывести -1.

Исходно множество S пусто. Первая строка входного файла содержит n — количество операций (1 ≤ n ≤ 300000). Следующие n строк содержат операции. Каждая операция имеет вид либо "+ i", либо "? i". Операция "? i" задает запрос next(i).
Если операция "+ i" идет во входном файле в начале или после другой операции "+", то она задает операцию add(i). Если же она идет после запроса "?", и результат этого запроса был y, то выполняется операция add((i + y) mod 109).
Во всех запросах и операциях добавления параметры лежат в интервале от 0 до 109.

Для каждого запроса выведите одно число — ответ на запрос.
### E Максимум на подотрезках с добавлением на отрезке
Реализуйте эффективную структуру данных для хранения массива и выполнения следующих операций: увеличение всех элементов данного интервала на одно и то же число; поиск максимума на интервале.

В первой строке вводится одно натуральное число N (1 ≤ N ≤ 100000) — количество чисел в массиве.
Во второй строке вводятся N чисел от 0 до 100000 — элементы массива.
В третьей строке вводится одно натуральное число M (1 ≤ M ≤ 30000) — количество запросов.
Каждая из следующих M строк представляет собой описание запроса. Сначала вводится одна буква, кодирующая вид запроса (m — найти максимум, a — увеличить все элементы на отрезке).
Следом за m вводятся два числа — левая и правая граница интервала.
Следом за a вводятся три числа — левый и правый концы отрезка и число add, на которое нужно увеличить все элементы данного отрезка массива (0 ≤ add ≤ 100000).

Выведите в одну строку через пробел ответы на каждый запрос m.

### F Декартово дерево по неявному ключу
Бригадир Коноводов любит командовать своей бригадой. Его любимый приказ "в начало строя". Он выстраивает свою бригаду в шеренгу и оглашает последовательность приказов. Каждый приказ имеет вид "Холопы с li по ri — в начало строя!"
Пронумеруем холопов в начальном положении с 1 до n, слева направо. Приказ "Холопы с li по ri — в начало строя!" означает, что холопы, стоящие с li по ri включительно, перемещаются в начало строя, сохраняя относительный порядок.
Например, если в некоторый момент холопы стоят в порядке 2, 3, 6, 1, 5, 4, после приказа: "Холопы с 2 по 4 — в начало строя!" порядок будет 3, 6, 1, 2, 5, 4.
По данной последовательности приказов найти конечный порядок холопов в строю.

В первой строке два целых числа n and m (2 ≤ n ≤ 100000, 1 ≤ m ≤ 100000) — количество холопов и количество приказов. Следующие m строк содержат по два целых числа li и ri (1 ≤ li ≤ ri ≤ n).

Выведите n целых чисел — порядок холопов в конечном положении после выполнения всех приказов.

Программу пишите аккуратно, разборчивым почерком.



